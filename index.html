<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Veddit ‚Äî Feed</title>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-storage-compat.js"></script>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{--bg:#f5f7fb;--card:#fff;--muted:#6b7280;--accent:#4f46e5;--danger:#ef4444;--success:#16a34a}
    body{font-family:Inter,system-ui,Arial;margin:0;padding:20px;background:#f4f6fb}
    .wrap{max-width:1000px;margin:0 auto}
    header{display:flex;justify-content:space-between;align-items:center}
    h1{margin:0;font-size:20px}
    .small{font-size:13px;color:var(--muted)}
    .card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 20px rgba(12,20,40,0.06);margin-bottom:12px}
    input,textarea,select{padding:10px;border-radius:8px;border:1px solid #e6e9ef;width:100%;box-sizing:border-box}
    button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
    button.ghost{background:#fff;color:var(--accent);border:1px solid #e6e9ef}
    button.small{font-size:12px;padding:4px 8px}
    .row{display:flex;gap:8px}
    .col{flex:1}
    .question{padding:12px;border-radius:10px;border-left:4px solid #eef2ff;margin-bottom:10px}
    .reply{background:#fafafa;padding:8px;border-radius:10px;margin-top:8px;border:1px solid #eef0f6}
    .inline{display:inline-flex;gap:8px;align-items:center}
    .link{color:var(--accent);cursor:pointer;text-decoration:underline}
    .hidden{display:none}
    .votes{display:flex;gap:6px;align-items:center}
    .votes button{background:#fff;border:1px solid #e6e9ef;padding:6px;border-radius:6px;color:#222}
    .modal{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:rgba(10,10,20,0.45);z-index:1000}
    .modal .card{max-width:680px;width:90%;max-height:80vh;overflow-y:auto}
    .small-muted{font-size:12px;color:var(--muted)}
    .indent{margin-left:18px}
    .collapse-toggle{color:#2563eb;cursor:pointer;font-size:13px;margin-top:8px}
    @media (max-width:720px){ .row{flex-direction:column} header{flex-direction:column;align-items:flex-start;gap:10px} }
  </style>
</head>
<body>
  <script src="js/firebase.js"></script>
  <div class="wrap">
    <header>
      <div>
        <h1>Veddit ‚Äî Campus Doubt Forum</h1>
        <div class="small">Forum with posts, nested replies, likes/dislikes, and moderation</div>
      </div>
      <div id="authArea" class="small">
        <span id="authStatus">Not signed in</span>
        <div style="margin-top:8px">
          <span id="authLinks">
            <a href="signup.html" class="link">Sign up / Login</a>
          </span>
          <button id="signOutBtn" class="ghost" style="display:none">Sign out</button>
        </div>
      </div>
    </header>

    <div id="postMin" class="card" style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Have a doubt?</strong><div class="small">Click to open quick post</div></div>
      <div><button id="openPostBtn">Ask a doubt</button></div>
    </div>

    <div id="postCard" class="card hidden">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Ask a doubt</strong>
        <button id="closePostBtn" class="ghost">Close</button>
      </div>

      <div style="margin-top:8px" class="small">Title</div>
      <input id="qTitle" placeholder="Short title (optional)">

      <div style="margin-top:8px" class="small">Body</div>
      <textarea id="qBody" rows="3" placeholder="Explain your doubt"></textarea>

      <div class="row" style="margin-top:8px;align-items:center">
        <div style="flex:1"><input id="qTag" placeholder="Tag (CS101, Hostel)" /></div>
        <div style="width:150px"><label><input type="checkbox" id="qAnon"> Post anonymously</label></div>
        <div style="width:180px"><input id="qImage" type="file" accept="image/*"/></div>
        <div style="width:110px"><button id="postBtn">Post</button></div>
      </div>
      <div id="postStatus" class="small-muted" style="margin-top:8px"></div>
    </div>

    <div id="feed" class="card">
      <strong>Recent doubts</strong>
      <div id="feedList" style="margin-top:12px"></div>
    </div>
  </div>

  <div id="replyModal" class="modal" style="display:none">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong id="modalTitle">Reply</strong>
        <button id="closeModal" class="ghost">Close</button>
      </div>
      <div style="margin-top:8px" id="modalContext" class="small-muted"></div>
      <textarea id="modalText" rows="4" placeholder="Write your reply..." style="margin-top:8px"></textarea>
      <div style="display:flex;align-items:center;gap:10px;margin-top:8px">
        <label id="modalAnonLabel"><input id="modalAnon" type="checkbox"/> Reply anonymously</label>
        <button id="modalPostBtn">Post reply</button>
        <div id="modalStatus" class="small-muted"></div>
      </div>
    </div>
  </div>

<script>
  let currentUser = null;
  const authStatus = document.getElementById('authStatus');
  const signOutBtn = document.getElementById('signOutBtn');
  const authLinks = document.getElementById('authLinks');

  const postMin = document.getElementById('postMin');
  const openPostBtn = document.getElementById('openPostBtn');
  const postCard = document.getElementById('postCard');
  const closePostBtn = document.getElementById('closePostBtn');
  const qTitle = document.getElementById('qTitle');
  const qBody = document.getElementById('qBody');
  const qTag = document.getElementById('qTag');
  const qAnon = document.getElementById('qAnon');
  const qImage = document.getElementById('qImage');
  const postBtn = document.getElementById('postBtn');
  const postStatus = document.getElementById('postStatus');

  const feedList = document.getElementById('feedList');

  const replyModal = document.getElementById('replyModal');
  const closeModal = document.getElementById('closeModal');
  const modalTitle = document.getElementById('modalTitle');
  const modalContext = document.getElementById('modalContext');
  const modalText = document.getElementById('modalText');
  const modalAnon = document.getElementById('modalAnon');
  const modalAnonLabel = document.getElementById('modalAnonLabel');
  const modalPostBtn = document.getElementById('modalPostBtn');
  const modalStatus = document.getElementById('modalStatus');

  const limitRepliesBeforeCollapse = 3;
  const activeListeners = new Map();

  // Utility functions
  function escapeHtml(s){ 
    if(!s) return ''; 
    return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); 
  }

  // Moderation check
  async function checkModeration(text){
    const blocked = ["sex","porn","fuck","shit","bomb","kill"];
    const lower = (text||'').toLowerCase();
    for(const b of blocked) if(lower.includes(b)) return false;
    return true;
  }

  // Ban enforcement
  async function isBanned(uid){
    if(!uid) return false;
    try{
      const banDoc = await db.collection('bans').doc(uid).get();
      if(!banDoc.exists) return false;
      const d = banDoc.data();
      const now = Date.now();
      const expiresAt = d.expiresAt?.toMillis ? d.expiresAt.toMillis() : d.expiresAt;
      if(expiresAt && now < expiresAt){
        return true;
      } else {
        await db.collection('bans').doc(uid).delete().catch(()=>{});
        return false;
      }
    }catch(e){
      console.warn('Ban check failed:', e);
      return false;
    }
  }

  // Auth handling
  auth.onAuthStateChanged(async u => {
    if(u){
      const doc = await db.collection('users').doc(u.uid).get();
      const profile = doc.exists ? doc.data() : { username: u.email.split('@')[0], role: 'student' };
      currentUser = { 
        uid: u.uid, 
        email: u.email, 
        username: profile.username || u.email.split('@')[0], 
        role: profile.role || 'student' 
      };
      authStatus.innerText = `${currentUser.username} (${currentUser.role})`;
      signOutBtn.style.display = 'inline-block';
      authLinks.style.display = 'none';
    } else {
      currentUser = null;
      authStatus.innerText = 'Not signed in';
      signOutBtn.style.display = 'none';
      authLinks.style.display = 'inline';
    }
  });

  signOutBtn.onclick = ()=> auth.signOut();

  // Post card toggle
  openPostBtn.onclick = ()=> {
    postMin.classList.add('hidden');
    postCard.classList.remove('hidden');
    qTitle.focus();
  };
  
  closePostBtn.onclick = ()=> {
    postCard.classList.add('hidden');
    postMin.classList.remove('hidden');
  };

  // Posting question
  postBtn.onclick = async ()=>{
    if(!currentUser) return alert('Login first');
    if(await isBanned(currentUser.uid)) return alert('You are temporarily banned');

    const title = qTitle.value.trim();
    const body = qBody.value.trim();
    const tag = qTag.value.trim() || 'general';
    const anon = qAnon.checked;
    const file = qImage.files[0];

    if(!title && !body) { 
      postStatus.innerText = 'Add title or body'; 
      return; 
    }
    
    postStatus.innerText = 'Checking...';
    if(!await checkModeration(title + ' ' + body)) { 
      postStatus.innerText = 'Blocked by moderation'; 
      return; 
    }
    
    postStatus.innerText = 'Posting...';

    try{
      const qRef = await db.collection('questions').add({
        title, 
        body, 
        tag,
        anon: !!anon,
        authorUid: currentUser.uid,
        authorName: anon ? 'Anonymous' : currentUser.username,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        image: null,
        likes: 0, 
        dislikes: 0
      });
      
      if(file){
        const ref = storage.ref().child(`questions/${qRef.id}/${Date.now()}_${file.name}`);
        await ref.put(file);
        const url = await ref.getDownloadURL();
        await qRef.update({ image: url });
      }
      
      postStatus.innerText = 'Posted!';
      setTimeout(()=>postStatus.innerText = '', 1000);
    }catch(e){
      postStatus.innerText = 'Post failed: ' + e.message;
    }
    qTitle.value="";
    qBody.value="";
    qImage.value = "";
    postCard.classList.add('hidden');
    postMin.classList.remove('hidden');

  };

  // Vote on question
  
  async function voteQuestion(qid, value){
    if(!currentUser) return alert('Login to vote');
    if(await isBanned(currentUser.uid)) return alert('You are banned');

    const voteRef = db.collection('questions').doc(qid).collection('votes').doc(currentUser.uid);
    const qRef = db.collection('questions').doc(qid);

    try{
      await db.runTransaction(async tx => {
        const voteDoc = await tx.get(voteRef);
        const qDoc = await tx.get(qRef);
        if(!qDoc.exists) throw new Error('Question not found');

        let likes = qDoc.data().likes || 0;
        let dislikes = qDoc.data().dislikes || 0;

        if(voteDoc.exists){
          const prev = voteDoc.data().value;
          if(prev === value){
            tx.delete(voteRef);
            if(value === 1) likes--; else dislikes--;
          } else {
            tx.update(voteRef, { value });
            if(value === 1){ likes++; dislikes--; } else { likes--; dislikes++; }
          }
        } else {
          tx.set(voteRef, { value });
          if(value === 1) likes++; else dislikes++;
        }
        
        tx.update(qRef, { likes, dislikes });
      });
    }catch(e){
      console.error('Vote failed:', e);
    }
  }

  // Vote on reply
  async function voteReply(parentPath, rid, value){
    if(!currentUser) return alert('Login to vote');
    if(await isBanned(currentUser.uid)) return alert('You are banned');

    const voteDocRef = db.doc(`${parentPath}/replies/${rid}/votes/${currentUser.uid}`);
    const replyRef = db.doc(`${parentPath}/replies/${rid}`);
    
    try{
      await db.runTransaction(async tx =>{
        const vdoc = await tx.get(voteDocRef);
        const rdoc = await tx.get(replyRef);
        if(!rdoc.exists) throw new Error('Reply not found');
        
        let likes = rdoc.data().likes || 0;
        let dislikes = rdoc.data().dislikes || 0;
        
        if(vdoc.exists){
          const prev = vdoc.data().value;
          if(prev === value){
            tx.delete(voteDocRef);
            if(value===1) likes--; else dislikes--;
          } else {
            tx.update(voteDocRef, { value });
            if(value===1){ likes++; dislikes--; } else { likes--; dislikes++; }
          }
        } else {
          tx.set(voteDocRef, { value });
          if(value===1) likes++; else dislikes++;
        }
        
        tx.update(replyRef, { likes, dislikes });
      });
    }catch(e){
      console.error('Reply vote failed:', e);
    }
  }

  // Clean up listener
  function cleanupListener(key){
    if(activeListeners.has(key)){
      const unsub = activeListeners.get(key);
      if(typeof unsub === 'function') unsub();
      activeListeners.delete(key);
    }
  }

  // Render replies for a parent
  function renderRepliesForParent(parentPath, container, depth = 0, collapsedMode = false){
    const listenerKey = `replies_${parentPath}`;
    cleanupListener(listenerKey);
    
    container.innerHTML = '';
    const colPath = parentPath + '/replies';
    
    const q = db.collection(colPath).orderBy('createdAt','asc');
    const unsub = q.onSnapshot(snapshot => {
      container.innerHTML = '';
      const docs = snapshot.docs;
      const total = docs.length;
      const showCount = collapsedMode ? Math.min(limitRepliesBeforeCollapse, total) : total;
      
      for(let i=0; i<showCount; i++){
        const doc = docs[i];
        const data = doc.data();
        const rid = doc.id;
        const wrapper = document.createElement('div');
        wrapper.className = 'reply';
        wrapper.style.marginLeft = (depth * 18) + 'px';
        const author = data.anon ? 'Anonymous' : (data.authorName || 'Unknown');
        const time = data.createdAt ? data.createdAt.toDate().toLocaleString() : '';

        wrapper.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:flex-start">
            <div style="flex:1">
              <div><strong>${escapeHtml(author)}</strong> <span class="small-muted">${escapeHtml(time)}</span></div>
              <div style="margin-top:6px">${escapeHtml(data.text)}</div>
              <div style="margin-top:8px" class="inline">
                <button class="replyBtn small" data-path="${parentPath}" data-rid="${rid}">Reply</button>
                <button class="likeReply small" data-path="${parentPath}" data-rid="${rid}">üëç <span class="r-like-count">${data.likes||0}</span></button>
                <button class="dislikeReply small" data-path="${parentPath}" data-rid="${rid}">üëé <span class="r-dislike-count">${data.dislikes||0}</span></button>
              </div>
            </div>
            <div style="text-align:right">
              ${currentUser && currentUser.role === 'operator' ? `<button class="op-delete-reply" data-path="${parentPath}" data-rid="${rid}" style="background:#fff;color:#ef4444;border:1px solid #fee2e2;padding:6px;border-radius:6px;font-size:12px">Delete</button>` : ''}
            </div>
          </div>
          <div class="children" id="children-${escapeHtml(parentPath.replace(/\//g,'_'))}_${rid}"></div>
        `;
        container.appendChild(wrapper);

        // Reply button
        wrapper.querySelector('.replyBtn').onclick = () => {
          if(!currentUser) return alert('Login to reply');
          const path = `${parentPath}/replies/${rid}`;
          openReplyModal(path, data.text);
        };

        // Like/dislike buttons
        wrapper.querySelector('.likeReply').onclick = () => voteReply(parentPath, rid, 1);
        wrapper.querySelector('.dislikeReply').onclick = () => voteReply(parentPath, rid, -1);

        // Operator delete
        const opDel = wrapper.querySelector('.op-delete-reply');
        if(opDel){
          opDel.onclick = async () => {
            if(!confirm('Delete this reply?')) return;
            try{
              await db.doc(`${parentPath}/replies/${rid}`).delete();
            }catch(e){
              alert('Delete failed: ' + e.message);
            }
          };
        }

        // Recursively render children
        const childContainer = wrapper.querySelector(`#children-${escapeHtml(parentPath.replace(/\//g,'_'))}_${rid}`);
        renderRepliesForParent(`${parentPath}/replies/${rid}`, childContainer, depth+1, collapsedMode);
      }

      // Show more button
      if(collapsedMode && total > showCount){
        const more = document.createElement('div');
        more.className = 'collapse-toggle';
        more.innerText = `Show ${total - showCount} more replies`;
        more.onclick = ()=> renderRepliesForParent(parentPath, container, depth, false);
        container.appendChild(more);
      }
    });
    
    activeListeners.set(listenerKey, unsub);
  }

  // Open reply modal
  function openReplyModal(parentPath, contextText = ''){
    replyModal.style.display = 'flex';
    modalTitle.innerText = 'Reply';
    modalContext.innerHTML = contextText ? `<div class="small-muted">Replying to: ${escapeHtml(contextText)}</div>` : '';
    modalText.value = '';
    modalAnon.checked = false;
    replyModal.dataset.parent = parentPath;
    
    // Clear any existing reply list
    const list = document.getElementById('modal-replies-container');
    if(list) list.remove();
  }

  // Thread view
  async function openThreadView(qid){
    const qdoc = await db.collection('questions').doc(qid).get();
    if(!qdoc.exists) return alert('Question not found');
    
    const q = qdoc.data();
    const author = q.anon ? 'Anonymous' : (q.authorName || 'Unknown');
    
    replyModal.style.display = 'flex';
    modalTitle.innerText = 'Thread';
    modalContext.innerHTML = `
      <strong>${escapeHtml(q.title || '(no title)')}</strong>
      <div class="small-muted">${escapeHtml(author)} ‚Ä¢ ${escapeHtml(q.tag || 'general')}</div>
      <div style="margin-top:8px">${escapeHtml(q.body || '')}</div>
      ${q.image ? `<div style="margin-top:8px"><img src="${q.image}" style="max-width:100%;border-radius:8px"></div>` : ''}
    `;
    
    modalText.value = '';
    modalAnon.checked = false;
    replyModal.dataset.parent = `questions/${qid}`;

    let list = document.getElementById('modal-replies-container');
    if(list) list.remove();
    list = document.createElement('div');
    list.id = 'modal-replies-container';
    list.style.marginTop = '12px';
    modalContext.appendChild(list);
    
    renderRepliesForParent(`questions/${qid}`, list, 0, false);
  }

  // Close modal
  closeModal.onclick = ()=> {
    replyModal.style.display = 'none';
    modalText.value = '';
    modalStatus.innerText = '';
    
    const list = document.getElementById('modal-replies-container');
    if(list) {
      const parentPath = replyModal.dataset.parent;
      if(parentPath) cleanupListener(`replies_${parentPath}`);
      list.remove();
    }
  };

  // Modal post button - single handler
  modalPostBtn.onclick = async ()=>{
    if(!currentUser) return alert('Login first');
    if(await isBanned(currentUser.uid)) return alert('You are banned');

    const parent = replyModal.dataset.parent;
    if(!parent) return alert('No parent to reply to');

    const text = modalText.value.trim();
    const anon = modalAnon.checked;
    if(!text) {
      modalStatus.innerText = 'Write a reply';
      return;
    }

    modalStatus.innerText = 'Checking...';
    if(!await checkModeration(text)) { 
      modalStatus.innerText = 'Blocked by moderation'; 
      return; 
    }

    try{
      await db.doc(parent).collection('replies').add({
        text, 
        anon, 
        authorUid: currentUser.uid,
        authorName: anon ? 'Anonymous' : currentUser.username,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        likes: 0, 
        dislikes: 0
      });
      
      modalStatus.innerText = 'Posted';
      modalText.value = '';
      setTimeout(()=> modalStatus.innerText = '', 900);
    }catch(e){
      modalStatus.innerText = 'Failed: ' + e.message;
    }
  };

  // Feed realtime listener
  db.collection('questions').orderBy('createdAt','desc').onSnapshot(async snap => {
    feedList.innerHTML = '';
    
    for(const doc of snap.docs){
      const qid = doc.id;
      const d = doc.data();
      const author = d.anon ? 'Anonymous' : (d.authorName || 'Unknown');
      const time = d.createdAt ? d.createdAt.toDate().toLocaleString() : '';
      
      const el = document.createElement('div');
      el.className = 'question';
      el.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:flex-start">
          <div style="flex:1">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div>
                <strong>${escapeHtml(d.title || '(no title)')}</strong>
                <div class="small-muted">${escapeHtml(author)} ‚Ä¢ ${escapeHtml(d.tag || 'general')} ‚Ä¢ ${escapeHtml(time)}</div>
              </div>
              <div style="text-align:right">
                <div class="votes">
                  <button class="likeBtn" data-id="${qid}">‚¨Ü <span class="count-like">${d.likes||0}</span></button>
                  <button class="dislikeBtn" data-id="${qid}">‚¨á <span class="count-dislike">${d.dislikes||0}</span></button>
                </div>
                <div style="margin-top:6px">
                  <span class="link viewThread" data-id="${qid}">View thread</span>
                </div>
              </div>
            </div>
            <div style="margin-top:8px">${escapeHtml(d.body || '')}</div>
            ${d.image ? `<div style="margin-top:8px"><img src="${d.image}" style="max-width:220px;border-radius:8px"></div>` : ''}
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="col small-muted"></div>
          <div style="width:260px;text-align:right">
            ${currentUser && currentUser.role === 'operator' ? `
              <button class="op-delete" data-id="${qid}" style="background:#fff;color:#ef4444;border:1px solid #fee2e2;padding:6px;border-radius:6px;font-size:12px">Delete</button>
              <button class="op-ban" data-id="${qid}" style="background:#fff;color:#111;border:1px solid #e6e9ef;padding:6px;border-radius:6px;font-size:12px">Ban user</button>
            ` : ''}
          </div>
        </div>
      `;
      feedList.appendChild(el);

      // View thread
      el.querySelector('.viewThread').onclick = ()=> openThreadView(qid);

      // Operator controls
      if(currentUser && currentUser.role === 'operator'){
        const delBtn = el.querySelector('.op-delete');
        if(delBtn){
          delBtn.onclick = async () => {
            if(!confirm('Delete post permanently?')) return;
            try{
              await db.collection('questions').doc(qid).delete();
            }catch(e){
              alert('Delete failed: ' + e.message);
            }
          };
        }
        
        const banBtn = el.querySelector('.op-ban');
        if(banBtn){
          banBtn.onclick = async () => {
            const min = parseInt(prompt('Ban this post author for how many minutes?', '60'), 10);
            if(isNaN(min) || min <= 0) return alert('Invalid time');
            
            try{
              const qdoc = await db.collection('questions').doc(qid).get();
              if(!qdoc.exists) return alert('Post not found');
              
              const authorUid = qdoc.data().authorUid;
              const expiresAt = Date.now() + min * 60 * 1000;
              await db.collection('bans').doc(authorUid).set({ expiresAt });
              alert(`Banned for ${min} minutes`);
            }catch(e){
              alert('Ban failed: ' + e.message);
            }
          };
        }
      }

      // Don't render replies in feed - only show in thread view
    }
  });
</script>
</body>
</html>